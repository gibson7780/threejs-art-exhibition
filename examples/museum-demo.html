<!DOCTYPE html>
<html lang="en">
  <head>
    <title>js webgl - box projected cubemap environment mapping</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js"></script> -->

    <!-- <script src="./jsm/controls/PointerLockControls.js"></script> -->
  </head>
  <body>
    <div id="menuPanel">
      <div id="startButton">
        <span style="font-size: 40px">點擊開始</span>
        <br />
        <br />
        (W, A, S, D = 移動, 滑鼠移動 = 移動視角, ESC = 結束)
      </div>
    </div>
    <script type="module">
      import * as THREE from '../build/three.module.js';

      import { GUI } from './jsm/libs/dat.gui.module.js';
      import { OrbitControls } from './jsm/controls/OrbitControls.js';
      import { RectAreaLightHelper } from './jsm/helpers/RectAreaLightHelper.js';
      import { RectAreaLightUniformsLib } from './jsm/lights/RectAreaLightUniformsLib.js';
      import { PointerLockControls } from './jsm/controls/PointerLockControls.js';
      import Stats from './jsm/libs/stats.module.js';

      // shader injection for box projected cube environment mapping
      const worldposReplace = /* glsl */ `
      			#define BOX_PROJECTED_ENV_MAP

      			#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )

      				vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );

      				#ifdef BOX_PROJECTED_ENV_MAP

      					vWorldPosition = worldPosition.xyz;

      				#endif

      			#endif
      			`;

      const envmapPhysicalParsReplace = /* glsl */ `
      			#if defined( USE_ENVMAP )

      				#define BOX_PROJECTED_ENV_MAP

      				#ifdef BOX_PROJECTED_ENV_MAP

      					uniform vec3 cubeMapSize;
      					uniform vec3 cubeMapPos;
      					varying vec3 vWorldPosition;

      					vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {

      						vec3 nDir = normalize( v );
      						vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;
      						vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;

      						vec3 rbminmax;
      						rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;
      						rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;
      						rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;

      						float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );
      						vec3 boxIntersection = vWorldPosition + nDir * correction;

      						return boxIntersection - cubePos;
      					}

      				#endif

      				#ifdef ENVMAP_MODE_REFRACTION
      					uniform float refractionRatio;
      				#endif

      				vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {

      					vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

      					#ifdef ENVMAP_TYPE_CUBE

      						#ifdef BOX_PROJECTED_ENV_MAP

      							worldNormal = parallaxCorrectNormal( worldNormal, cubeMapSize, cubeMapPos );

      						#endif

      						vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );

      						// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level
      						// of a specular cubemap, or just the default level of a specially created irradiance cubemap.

      						#ifdef TEXTURE_LOD_EXT

      							vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );

      						#else

      							// force the bias high to get the last LOD level as it is the most blurred.
      							vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );

      						#endif

      						envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

      					#elif defined( ENVMAP_TYPE_CUBE_UV )

      						vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );

      					#else

      						vec4 envMapColor = vec4( 0.0 );

      					#endif

      					return PI * envMapColor.rgb * envMapIntensity;

      				}

      				// Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html
      				float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {

      					float maxMIPLevelScalar = float( maxMIPLevel );

      					float sigma = PI * roughness * roughness / ( 1.0 + roughness );
      					float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );

      					// clamp to allowable LOD ranges.
      					return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );

      				}

      				vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {

      					#ifdef ENVMAP_MODE_REFLECTION

      						vec3 reflectVec = reflect( -viewDir, normal );

      						// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
      						reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

      					#else

      						vec3 reflectVec = refract( -viewDir, normal, refractionRatio );

      					#endif

      					reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

      					float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );

      					#ifdef ENVMAP_TYPE_CUBE

      						#ifdef BOX_PROJECTED_ENV_MAP
      							reflectVec = parallaxCorrectNormal( reflectVec, cubeMapSize, cubeMapPos );
      						#endif

      						vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );

      						#ifdef TEXTURE_LOD_EXT

      							vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );

      						#else

      							vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );

      						#endif

      						envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

      					#elif defined( ENVMAP_TYPE_CUBE_UV )

      						vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );

      					#endif

      					return envMapColor.rgb * envMapIntensity;
      				}
      			#endif
      			`;

      // scene size
      const WIDTH = window.innerWidth;
      const HEIGHT = window.innerHeight;

      // camera
      const VIEW_ANGLE = 45;
      const ASPECT = WIDTH / HEIGHT;
      const NEAR = 1;
      const FAR = 800;

      // PointerLockControls setting
      let controls;
      let moveForward = false;
      let moveBackward = false;
      let moveLeft = false;
      let moveRight = false;
      let canJump = false;
      let raycaster;

      let prevTime = Date.now(); // 初始時間
      let velocity = new THREE.Vector3(); // 移動速度向量
      let direction = new THREE.Vector3(); // 移動方向向量
      let camera, cubeCamera, scene, renderer;

      let cameraControls;

      let groundPlane, wallMat, wallMatPaintingMat1, wallMatPaintingMat2;
      let geometry;
      let cube;
      init();

      const menuPanel = document.getElementById('menuPanel');
      const startButton = document.getElementById('startButton');
      menuPanel.addEventListener(
        'click',
        function () {
          controls.lock();
        },
        false
      );
      // 鼠標鎖定初始化
      controls = new PointerLockControls(camera);
      // controls.getObject().position.set(10, 0, 60)
      scene.add(controls.getObject());
      // controls = new PointerLockControls(camera, renderer.domElement);
      controls.addEventListener(
        'lock',
        () => (menuPanel.style.display = 'none')
      );
      controls.addEventListener(
        'unlock',
        () => (menuPanel.style.display = 'block')
      );

      function init() {
        // renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(WIDTH, HEIGHT);
        document.body.appendChild(renderer.domElement);

        // gui controls
        const gui = new GUI();
        const params = {
          'box projected': true,
        };
        const bpcemGui = gui.add(params, 'box projected');

        bpcemGui.onChange(function (value) {
          if (value) {
            groundPlane.material = boxProjectedMat;
          } else {
            groundPlane.material = defaultMat;
          }

          render();
        });

        // scene
        scene = new THREE.Scene();

        // camera
        camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
        camera.position.set(100, 50, 0);

        cameraControls = new OrbitControls(camera, renderer.domElement);
        cameraControls.target.set(0, -10, 0);
        cameraControls.maxDistance = 400;
        cameraControls.minDistance = 10;
        cameraControls.addEventListener('change', render);
        cameraControls.update();

        // cube camera for environment map

        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, {
          format: THREE.RGBFormat,
          generateMipmaps: true,
          minFilter: THREE.LinearMipmapLinearFilter,
        });
        cubeCamera = new THREE.CubeCamera(1, 1000, cubeRenderTarget);

        cubeCamera.position.set(0, 100, 0);
        scene.add(cubeCamera);

        // ground floor ( with box projected environment mapping )
        const loader = new THREE.TextureLoader();
        const rMap = loader.load('textures/lava/lavatile.jpg');
        rMap.wrapS = THREE.RepeatWrapping;
        rMap.wrapT = THREE.RepeatWrapping;
        rMap.repeat.set(2, 1);

        const defaultMat = new THREE.MeshPhysicalMaterial({
          roughness: 1,
          envMap: cubeRenderTarget.texture,
          roughnessMap: rMap,
        });

        const boxProjectedMat = new THREE.MeshPhysicalMaterial({
          color: new THREE.Color('#ffffff'),
          roughness: 1,
          envMap: cubeRenderTarget.texture,
          roughnessMap: rMap,
        });

        boxProjectedMat.onBeforeCompile = function (shader) {
          //these parameters are for the cubeCamera texture
          shader.uniforms.cubeMapSize = {
            value: new THREE.Vector3(200, 200, 100),
          };
          shader.uniforms.cubeMapPos = { value: new THREE.Vector3(0, -50, 0) };

          //replace shader chunks with box projection chunks
          shader.vertexShader =
            'varying vec3 vWorldPosition;\n' + shader.vertexShader;

          shader.vertexShader = shader.vertexShader.replace(
            '#include <worldpos_vertex>',
            worldposReplace
          );

          shader.fragmentShader = shader.fragmentShader.replace(
            '#include <envmap_physical_pars_fragment>',
            envmapPhysicalParsReplace
          );
        };

        groundPlane = new THREE.Mesh(
          new THREE.PlaneGeometry(200, 100, 100),
          boxProjectedMat
        );
        groundPlane.rotateX(-Math.PI / 2);
        groundPlane.position.set(0, -49, 0);
        scene.add(groundPlane);

        // walls
        const paintingTex1 = loader.load('textures/scream.jpg', function () {
          updateCubeMap();
        });
        const paintingTex2 = loader.load(
          'textures/starry-night.jpg',
          function () {
            updateCubeMap();
          }
        );
        const diffuseTex = loader.load(
          'textures/brick_diffuse.jpg',
          function () {
            updateCubeMap();
          }
        );
        const bumpTex = loader.load('textures/brick_bump.jpg', function () {
          updateCubeMap();
        });

        // 球
        // geometry = new THREE.SphereGeometry(10, 32, 100);
        // const material = new THREE.MeshPhongMaterial({
        // 	color: 0x0000ff,
        // }); // 材質
        // 第一幅畫
        wallMatPaintingMat1 = new THREE.MeshPhysicalMaterial({
          map: paintingTex1,
          // bumpMap: bumpTex,
          // bumpScale: 0.3,
          // side: THREE.DoubleSide,
        });
        // 第二幅畫
        wallMatPaintingMat2 = new THREE.MeshPhysicalMaterial({
          map: paintingTex2,
          // bumpMap: bumpTex,
          // bumpScale: 0.3,
          // side: THREE.DoubleSide,
        });

        wallMat = new THREE.MeshPhysicalMaterial({
          map: diffuseTex,
          bumpMap: bumpTex,
          bumpScale: 2,
          // side: THREE.DoubleSide,
        });

        // cube = new THREE.Mesh(geometry, material); // 建立網格物件
        // cube.position.set(50, 0, 0);
        // scene.add(cube);

        // 第一幅畫面板寬高設定
        const paintingPanel1 = new THREE.PlaneGeometry(31.68, 40);
        // 第二幅畫面板寬高設定
        const paintingPanel2 = new THREE.PlaneGeometry(46.44, 35);

        // 素色
        // const material123 = new THREE.MeshBasicMaterial({
        // 	color: 0xffff00,
        // 	side: THREE.DoubleSide,
        // });
        // const plane = new THREE.Mesh(geometry123, material123);
        //第一幅畫面板貼圖設定
        const plane1 = new THREE.Mesh(paintingPanel1, wallMatPaintingMat1);
        plane1.position.set(40, 0, -49);
        // plane.rotateY(Math.PI / 2);
        scene.add(plane1);
        //第二幅畫面板貼圖設定
        const plane2 = new THREE.Mesh(paintingPanel2, wallMatPaintingMat2);
        plane2.position.set(-25, 0, -49);
        // plane.rotateY(Math.PI / 2);
        scene.add(plane2);
        // console.log("scene", scene);

        const planeGeo = new THREE.PlaneGeometry(100, 100); // 全部牆的寬高

        const planeBack1 = new THREE.Mesh(planeGeo, wallMat);
        planeBack1.position.z = -50;
        planeBack1.position.x = -50;
        // planeBack1.rotateY(Math.PI / 2);
        scene.add(planeBack1);

        const planeBack2 = new THREE.Mesh(planeGeo, wallMat);
        planeBack2.position.set(50, 0, -50);
        // planeBack2.position.x = 50;
        scene.add(planeBack2);

        const planeFront1 = new THREE.Mesh(planeGeo, wallMat);
        planeFront1.position.z = 50;
        planeFront1.position.x = -50;
        planeFront1.rotateY(Math.PI);
        scene.add(planeFront1);

        const planeFront2 = new THREE.Mesh(planeGeo, wallMat);
        planeFront2.position.z = 50;
        planeFront2.position.x = 50;
        planeFront2.rotateY(Math.PI);
        scene.add(planeFront2);

        const planeRight = new THREE.Mesh(planeGeo, wallMat);
        planeRight.position.x = 100;
        planeRight.rotateY(-Math.PI / 2);
        scene.add(planeRight);

        const planeLeft = new THREE.Mesh(planeGeo, wallMat);
        planeLeft.position.x = -100;
        planeLeft.rotateY(Math.PI / 2);
        scene.add(planeLeft);

        //lights
        const width = 25;
        const height = 25;
        const intensity = 30;
        RectAreaLightUniformsLib.init();

        // let pointLight2 = new THREE.PointLight(0xffffff);
        // pointLight2.position.set(0, 50, 0);
        // scene.add(pointLight2);

        let pointLight = new THREE.RectAreaLight(
          0xffffff,
          intensity,
          width,
          height
        );
        pointLight.position.set(99, 5, 0);
        pointLight.lookAt(0, 5, 0);
        scene.add(pointLight);
        // const pointLightHelper = new RectAreaLightHelper(pointLight);
        // pointLight.add(pointLightHelper);

        const blueRectLight = new THREE.RectAreaLight(
          0xfdf4dc,
          intensity,
          width,
          height
        );
        blueRectLight.position.set(99, 5, 0);
        blueRectLight.lookAt(0, 5, 0);
        // scene.add(blueRectLight);

        // const blueRectLightHelper = new RectAreaLightHelper(blueRectLight);
        // blueRectLight.add(blueRectLightHelper);

        const redRectLight = new THREE.RectAreaLight(
          0xfdf4dc,
          intensity,
          width,
          height
        );
        redRectLight.position.set(-99, 5, 0);
        redRectLight.lookAt(0, 5, 0);
        scene.add(redRectLight);

        // const redRectLightHelper = new RectAreaLightHelper(redRectLight);
        // redRectLight.add(redRectLightHelper);

        render();
      }

      function updateCubeMap() {
        //disable specular highlights on walls in the environment map
        wallMat.roughness = 1;

        groundPlane.visible = false;

        // cubeCamera.position.copy(groundPlane.position);

        cubeCamera.update(renderer, scene);

        wallMat.roughness = 0.6;

        groundPlane.visible = true;

        render();
      }

      const onKeyDown = function (event) {
        switch (event.keyCode) {
          case 38: // up
          case 87: // w
            moveForward = true;
            break;
          case 37: // left
          case 65: // a
            moveLeft = true;
            break;
          case 40: // down
          case 83: // s
            moveBackward = true;
            break;
          case 39: // right
          case 68: // d
            moveRight = true;
            break;
          case 32: // space
            if (canJump === true) velocity.y += 350; // 跳躍高度
            canJump = false;
            break;
        }
      };
      const onKeyUp = function (event) {
        switch (event.keyCode) {
          case 38: // up
          case 87: // w
            moveForward = false;
            break;
          case 37: // left
          case 65: // a
            moveLeft = false;
            break;
          case 40: // down
          case 83: // s
            moveBackward = false;
            break;
          case 39: // right
          case 68: // d
            moveRight = false;
            break;
        }
      };
      document.addEventListener('keydown', onKeyDown, false);
      document.addEventListener('keyup', onKeyUp, false);

      // const onKeyDown = function (event) {
      //   switch (event.key) {
      //     case 'w':
      //       controls.moveForward(3);
      //       break;
      //     case 'a':
      //       controls.moveRight(-3);
      //       break;
      //     case 's':
      //       controls.moveForward(-3);
      //       break;
      //     case 'd':
      //       controls.moveRight(3);
      //       break;
      //   }
      // };
      // document.addEventListener('keydown', onKeyDown, false);

      // 使用 Raycaster 實現簡單碰撞偵測
      raycaster = new THREE.Raycaster(
        new THREE.Vector3(),
        new THREE.Vector3(0, -1, 0),
        0,
        10
      );
      // const stats = Stats()
      // document.body.appendChild(stats.dom)

      function animate() {
        requestAnimationFrame(animate);
        render();
        // stats.update()
      }

      function render() {
        // requestAnimationFrame(render)
        // stats.update()
        // creeperFeetWalk()
        // pointsAnimation()
        // TWEEN.update()
        pointerLockControlsRender();
        renderer.render(scene, camera);
      }

      function pointerLockControlsRender() {
        if (controls && controls.isLocked) {
          // console.log('controls', controls.isLocked);
          // 使用 Raycaster 判斷腳下是否與場景中物體相交
          // raycaster.ray.origin.copy(controls.getObject().position); // 複製控制器的位置
          // const intersections = raycaster.intersectObjects(
          //   scene.children,
          //   true
          // ); // 判斷是否在任何物體上
          // const onObject = intersections.length > 0;

          // 計算時間差
          const time = Date.now();
          const delta = (time - prevTime) / 1000; // 大約為 0.016

          // 設定初始速度變化
          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;
          velocity.y -= 9.8 * 100.0 * delta; // 預設墜落速度

          // 判斷按鍵朝什麼方向移動，並設定對應方向速度變化
          direction.z = Number(moveForward) - Number(moveBackward);
          direction.x = Number(moveLeft) - Number(moveRight);
          // direction.normalize() // 向量正規化（長度為 1），確保每個方向保持一定移動量
          if (moveForward || moveBackward)
            velocity.z -= direction.z * 400.0 * delta;
          if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

          // 處理跳躍對應 y 軸方向速度變化
          // if (onObject === true) {
          //   velocity.y = Math.max(0, velocity.y);
          //   canJump = true;
          // }

          // 根據速度值移動控制器位置
          controls.getObject().translateX(velocity.x * delta);
          // controls.getObject().translateY(velocity.y * delta);
          controls.getObject().translateZ(velocity.z * delta);

          // 控制器下墜超過 -2000 則重置位置
          // if (controls.getObject().position.y < -2000) {
          //   velocity.y = 0;
          //   controls.getObject().position.set(0, 0, 0);
          //   canJump = true;
          // }

          prevTime = time;
        }
      }

      animate();
    </script>
  </body>
</html>
